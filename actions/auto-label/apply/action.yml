name: "Apply Codex auto-labels"
description: "Create missing labels when allowed and apply them to the issue."
inputs:
  github-token:
    description: "GitHub token with repo scope"
    required: true
  max-labels:
    description: "Maximum number of labels to apply."
    required: true
  create-missing-labels:
    description: "Allow creation of labels that do not already exist in the repository."
    required: false
    default: "true"
outputs:
  applied_labels:
    description: "Comma-separated list of labels that were applied."
    value: ${{ steps.apply.outputs.labels_csv }}
  applied_labels_json:
    description: "JSON array of labels that were applied."
    value: ${{ steps.apply.outputs.labels_json }}
runs:
  using: "composite"
  steps:
    - id: apply
      uses: actions/github-script@v7
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        MAX_LABELS: ${{ inputs.max-labels }}
        CREATE_MISSING: ${{ inputs.create-missing-labels }}
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const fs = require('fs');
          const { execFileSync } = require('child_process');

          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const fullRepo = `${owner}/${repo}`;
          const issueNumber = parseInt(fs.readFileSync('issue-number.txt', 'utf8').trim(), 10);

          const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
          const maxLabels = clamp(parseInt(process.env.MAX_LABELS || '3', 10) || 3, 1, 3);
          const allowCreate = (process.env.CREATE_MISSING || 'true').toLowerCase() === 'true';

          const repoLabels = new Set(JSON.parse(fs.readFileSync('repo-labels.json', 'utf8')));

          const parseColor = (value) => {
            if (!value) return null;
            const normalized = String(value).trim().replace(/^#/, '').toLowerCase();
            return /^[0-9a-f]{6}$/.test(normalized) ? normalized : null;
          };

          const parseDescription = (value) => {
            if (!value) return null;
            const trimmed = String(value).trim();
            return trimmed.length ? trimmed.slice(0, 140) : null;
          };

          const loadLabels = () => {
            try {
              const result = JSON.parse(fs.readFileSync('codex-output.json', 'utf8'));
              if (!Array.isArray(result.labels)) {
                return [];
              }
              return result.labels
                .map((entry) => {
                  if (typeof entry === 'string') {
                    return { name: entry.trim() };
                  }
                  if (entry && typeof entry === 'object' && typeof entry.name === 'string') {
                    return {
                      name: entry.name.trim(),
                      color: parseColor(entry.color),
                      description: parseDescription(entry.description)
                    };
                  }
                  return null;
                })
                .filter((entry) => entry && entry.name.length > 0);
            } catch (error) {
              core.warning(`Failed to parse Codex output: ${error.message}`);
              return [];
            }
          };

          const desiredLabels = loadLabels();
          if (!desiredLabels.length) {
            core.info('Codex returned no labels; skipping.');
            core.setOutput('labels_csv', '');
            core.setOutput('labels_json', '[]');
            return;
          }

          const uniqueLabels = [];
          for (const label of desiredLabels) {
            if (!uniqueLabels.find((existing) => existing.name === label.name)) {
              uniqueLabels.push(label);
            }
            if (uniqueLabels.length >= maxLabels) {
              break;
            }
          }

          const ensuredLabels = [];
          const runGh = (args) => {
            core.info(`gh ${args.join(' ')}`);
            execFileSync('gh', args, { stdio: 'inherit' });
          };

          for (const label of uniqueLabels) {
            const labelName = label.name;
            if (!repoLabels.has(labelName)) {
              if (!allowCreate) {
                core.info(`Skipping new label '${labelName}' (creation disabled).`);
                continue;
              }
              const color = label.color ?? '0ea5e9';
              const description = label.description ?? 'Auto-generated by Codex labeler';
              try {
                core.info(`Creating new label '${labelName}' via gh CLI.`);
                runGh([
                  'label',
                  'create',
                  labelName,
                  '--repo',
                  fullRepo,
                  '--color',
                  color,
                  '--description',
                  description
                ]);
                repoLabels.add(labelName);
              } catch (error) {
                core.warning(`Failed to create label '${labelName}': ${error.message}`);
                continue;
              }
            }
            ensuredLabels.push(labelName);
            if (ensuredLabels.length >= maxLabels) {
              break;
            }
          }

          if (!ensuredLabels.length) {
            core.info('No labels to apply after validation.');
            core.setOutput('labels_csv', '');
            core.setOutput('labels_json', '[]');
            return;
          }

          try {
            runGh([
              'issue',
              'edit',
              issueNumber.toString(),
              '--repo',
              fullRepo,
              ...ensuredLabels.flatMap((label) => ['--add-label', label])
            ]);
          } catch (error) {
            core.setFailed(`Failed to add labels via gh CLI: ${error.message}`);
            return;
          }

          core.info(`Applied labels to issue #${issueNumber}: ${ensuredLabels.join(', ')}`);
          core.setOutput('labels_csv', ensuredLabels.join(','));
          core.setOutput('labels_json', JSON.stringify(ensuredLabels));
